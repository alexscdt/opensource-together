---
description: Ceci donnes une documentation de la clean architecture utilis√© et de sa logique. Elle met du contexte quand on parle de notre clean architecture et de comment integrer de nouvelles choses si necessaire
globs: 
alwaysApply: false
---
# üèóÔ∏è Architecture du Monorepo et Configuration Docker Compose

## Vue d'ensemble du Monorepo

Le projet est structur√© en monorepo pour faciliter la gestion des diff√©rentes applications et packages partag√©s. Cela permet une meilleure organisation, une gestion centralis√©e des d√©pendances, et une optimisation des builds.

## Services Principaux

### Base de Donn√©es M√©tier (PostgreSQL)

- **Port** : 5433
- **Objectif** : Stockage des donn√©es principales de l'application

### Base de Donn√©es SuperTokens (PostgreSQL)

- **Port** : 5432
- **Objectif** : Stockage des donn√©es d'authentification

### SuperTokens Core

- **Port** : 3567
- **Objectif** : Service d'authentification

### Backend (NestJS)

- **Port** : 4000
- **Objectif** : Serveur API

### Frontend (Next.js)

- **Port** : 3000
- **Objectif** : Application web

## Configuration Docker Compose

- **Isolation des Services** : Chaque service est conteneuris√©, assurant une isolation compl√®te et une communication via un r√©seau Docker personnalis√©.
- **Volumes** : Utilisation de volumes pour la persistance des donn√©es et le rechargement √† chaud des applications.
- **V√©rifications de Sant√©** : Impl√©mentation de v√©rifications de sant√© pour garantir le bon d√©marrage et la disponibilit√© des services.
- **D√©pendances** : Utilisation de `depends_on` pour assurer l'ordre de d√©marrage correct des services.

## Avantages de cette Configuration

- **D√©veloppement Simplifi√©** : Hot reload et gestion centralis√©e des d√©pendances.
- **Scalabilit√©** : Facilit√© d'ajout de nouveaux services ou de mise √† jour des existants.
- **Maintenance** : Structure claire et modulaire facilitant la maintenance et l'√©volution du projet.

---

# üß± Architecture de l'application server ‚Äî Clean Architecture + CQRS avec NestJS

## üèóÔ∏è Vue d'ensemble

Le projet suit les principes de **Clean Architecture**, en s√©parant clairement les responsabilit√©s entre les couches :

- **Pr√©sentation (Interface)** : g√®re les entr√©es HTTP (contr√¥leurs)
- **Infrastructure** : Contient tout ce qui est librairie externe, impl√©mentation concrete des ports/interface (ORM, API tiers, services etc)
- **Application** : contient la logique m√©tier sous forme de Use Cases suivant le patern CQRS, Ports, Command/CommandHanlder et Querry/QuerryHandler (utilisation pragmatique de nestjs/cqrs)
- **Domaine** : le c≈ìur m√©tier pur contenant les invariants m√©tier (entity, value object, factory etc)

Le pattern **CQRS (Command Query Responsibility Segregation)** est utilis√© pour s√©parer clairement :

- les **commands** (√©criture)
- les **queries** (lecture)

Chaque action utilisateur transite par cette structure, facilitant le d√©couplage, le test et l'√©volution.

---

## üìÅ Structure des dossiers

### `src/application`

Contient la logique m√©tier applicative (use cases qui est sois query, sois command) et les abstractions n√©cessaires pour ex√©cuter ces cas d‚Äôusage (ports).

Les dossier suivent l'imbrication suivantes :

- `<business_entity_name>/commands/` :

  - Dossier contient toutes les use case commands, les fichier se pr√©sente ainsi :

    - `<business_intention>.command.ts` : Le nom du fichier commence par le nom du use case pour exprimer correctement l'intention m√©tier de la feature.

      - exemple type d'un fichier `.command.ts` :

      ````typescript
            import { Result } from '@shared/result';
            import { UserFactory } from '@/domain/user/user.factory';
            import { User } from '@domain/user/user.entity';
            import {
            USER_REPOSITORY_PORT,
            UserRepositoryPort,
            } from '../ports/user.repository.port';
            import { CommandHandler, ICommand, ICommandHandler } from '@nestjs/cqrs';
            import { Inject } from '@nestjs/common';

            export class CreateUserCommand implements ICommand {
                constructor(
                public readonly id: string,
                public readonly username: string,
                public readonly email: string,
                public readonly avatarUrl: string,
                public readonly bio: string,
                public readonly githubUrl: string,
                public readonly githubUserId: string,
                public readonly githubAccessToken: string,
                ) {}
            }

            @CommandHandler(CreateUserCommand)
            export class CreateUserCommandHandler implements ICommandHandler<CreateUserCommand>
            {
                constructor(
                    @Inject(USER_REPOSITORY_PORT)
                    private readonly userRepo: UserRepositoryPort,
                ) {}
                //business logic
            }
            ```
        - `<business_entity_name>.commands.ts`: Fichier servant de container pour regrouper tout les use case commands d'une entit√© m√©tier.
            - exemple type d'un fichier `.commands.ts` :
            ```typescript
            import {
                CreateUserCommand,
                CreateUserCommandHandler,
            } from './create-user.command';
            export const userCommandsContainer = [
                CreateUserCommand,
                CreateUserCommandHandler,
            ];
            ```
      ````

* `<business_entity_name>/query/` : Suit exactement le m√™me patern que ce qui est cit√© pour `<business_entity_name>/commands/`, a l'exception qu'ici ce sera en utilisant les query.

  - exemple de `<business_intention.query.ts>`:

    ```typescript
    import { IQuery, IQueryHandler, QueryHandler } from "@nestjs/cqrs";
    import { UserRepositoryPort } from "../ports/user.repository.port";
    import { USER_REPOSITORY_PORT } from "../ports/user.repository.port";
    import { Inject } from "@nestjs/common";

    export class UserExistQuery implements IQuery {
      constructor(
        public readonly username: string,
        public readonly email: string
      ) {}
    }

    @QueryHandler(UserExistQuery)
    export class UserExistHandler implements IQueryHandler<UserExistQuery> {
      constructor(
        @Inject(USER_REPOSITORY_PORT)
        private readonly userRepo: UserRepositoryPort
      ) {}

      async execute(query: UserExistQuery): Promise<boolean> {
        const userExistsByUsername = await this.userRepo.findByUsername(
          query.username
        );
        const userExistsByEmail = await this.userRepo.findByEmail(query.email);

        if (userExistsByUsername.success || userExistsByEmail.success) {
          return true;
        }
        return false;
      }
    }
    ```

    - exemple de `<business_entity_name.queries.ts>`:

    ```typescript
    import { FindUserByEmailQueryHandler } from "./find-user-by-email.query";
    import { FindUserByIdQueryHandler } from "./find-user-by-id.query";
    import { UserExistHandler } from "./user-exist.query";
    import { FindUserByUsernameQueryHandler } from "./find-user-by-username.query";
    export const userQueriesContainer = [
      FindUserByEmailQueryHandler,
      FindUserByIdQueryHandler,
      UserExistHandler,
      FindUserByUsernameQueryHandler,
    ];
    ```

* `<business_entity_name>/ports/` : Contient les fichier qui d√©finissent les ports, le contrat que doit respecter en input et output celui ci, afin de d√©coupler le technique du m√©tier. Il doit exprimer correctement l'intention et l'utilit√©, comme un service par exemple, ou un repository pour acc√©der au donn√©es. Par exemple un repository ressemblera a ceci :
  - exemple de `<business_entity_name>.repository.port.ts` :
  ```typescript
  import { User } from "@domain/user/user.entity";
  import { Result } from "@shared/result";
  export const USER_REPOSITORY_PORT = Symbol("UserRepository");
  export interface UserRepositoryPort {
    save(
      user: User
    ): Promise<Result<User, { username?: string; email?: string } | string>>;
    findByUsername(
      username: string
    ): Promise<Result<User, { username?: string; email?: string } | string>>;
    findByEmail(
      email: string
    ): Promise<Result<User, { username?: string; email?: string } | string>>;
    findById(
      id: string
    ): Promise<Result<User, { username?: string; email?: string } | string>>;
    update(
      user: User
    ): Promise<Result<User, { username?: string; email?: string } | string>>;
  }
  ```

- Le tout est ensuite rassembler et exporter via le fichier a la racine du dossier dans `src/application/<business_entity_name>/` contenant `commands/`, `queries/`, et `ports/` nommer `<business_entity_name>.application.ts` qui ressemble a ceci :
  ```typescript
  import { userQueriesContainer } from "./queries/user.queries";
  import { userCommandsContainer } from "./commands/user.commands";
  export const userApplicationContainer = [
    ...userQueriesContainer,
    ...userCommandsContainer,
  ];
  ```

### `src/domain`

Contient la repr√©sentation m√©tier pure, ind√©pendante de NestJS ou de toute autre lib/framework. Organis√© par entit√©.

- `email.vo.ts`, `username.vo.ts` ‚Üí Value Objects (`Email`, `Username`, etc.)
- `user.entity.ts` ‚Üí Entit√©
- `user.factory.ts` ‚Üí Fabrique pour cr√©er l‚Äôentit√© √† partir d'objets primitifs

**‚ú≥Ô∏è Convention de nommage VO :**

- Fichier : `xxx.vo.ts`
- Classe : `Email`, `Username`, etc. (pas besoin d‚Äôajouter "Vo" dans le nom de la classe)

### `src/infrastructures`

Couche technique contenant toutes les impl√©mentations concr√®tes des abstractions d√©finies dans la couche Application. Elle g√®re les d√©tails techniques et les int√©grations avec les syst√®mes externes.

- `auth/` : Int√©gration de l‚Äôauthentification (ex: Supertokens)
- `wiring` : : Couche de configuration et d'injection de d√©pendances qui fait le lien entre les couches Infrastructure et Application. Elle configure le container IoC de NestJS pour r√©soudre les d√©pendances.
- `repositories/` : Impl√©mentations concr√®tes des ports (ex: Prisma)
- `orm/` : Configuration ORM
  Cette s√©paration respecte le principe d'inversion de d√©pendance : l'Application d√©finit les contrats (ports), l'Infrastructure les impl√©mente, et le Wiring fait le lien

### `src/presentation`

Contient les contr√¥leurs NestJS, responsables de recevoir les requ√™tes HTTP et d‚Äôappeler les `CommandBus` / `QueryBus`.

- `user.controller.ts` : appel des Command ou Query selon la logique
- `dto/` : DTO de requ√™te/r√©ponse (ex: `XxxDtoRequest`, `XxxDtoResponse`)

> Les contr√¥leurs ne contiennent **aucune logique m√©tier**, seulement l‚Äôappel du bon use case et le formatage de la r√©ponse HTTP.

### `src/shared`

Contient tout ce qui est r√©utilisable globalement :

- `result.ts` : Impl√©mentation du **Result Pattern** pour √©viter les exceptions lev√©es de mani√®re incontr√¥l√©e. Permet de retourner des succ√®s ou des erreurs de fa√ßon explicite et typ√©e (`Result.ok()`, `Result.fail()`)

---

## üîÅ Flux de traitement typique (commandes)

1. Le contr√¥leur re√ßoit une requ√™te HTTP
2. Il utilise le `CommandBus` ou `QueryBus` pour d√©clencher l‚Äôaction
3. Le handler CQRS intercepte la commande et appelle le Use Case
4. Le Use Case applique la logique m√©tier et utilise les ports
5. L‚Äôimpl√©mentation concr√®te du port (infra) ex√©cute l‚Äôaction (ex: via Prisma)
6. Un objet `Result` est retourn√© au contr√¥leur, qui le transforme en r√©ponse HTTP
